plugins {
	id 'java'
	id 'application'
	id 'org.openjfx.javafxplugin' version '0.1.0'
}

wrapper {
	gradleVersion '8.10.2'
}

final def javaLangVersion = JavaLanguageVersion.of(21)
final def jvmVendor = JvmVendorSpec.ADOPTIUM

java {
	toolchain {
		languageVersion = javaLangVersion
		vendor = jvmVendor
	}
}
tasks.withType(JavaExec).configureEach {
	javaLauncher = javaToolchains.launcherFor {
		languageVersion = javaLangVersion
		vendor = jvmVendor
	}
}

final String fileNameSemVer = 'src/main/resources/de/bernd_michaely/chiffres/fx/version/svnrev'
final def fileSemVer = project(':module-gui-fx').file(fileNameSemVer)

final String propReadSvnRevision = 'jchiffresfx.isReadingSvnRevision'
ext.isReadingSvnRevision = project.hasProperty(propReadSvnRevision) ? Boolean.valueOf(project.getProperty(propReadSvnRevision)) : false
logger.lifecycle "-> Getting semantic version build number from subversion revision (user property »${propReadSvnRevision}«) : " + isReadingSvnRevision

def String readSvnRevision()
{
	def svnRev = ''
	if (isReadingSvnRevision) {
		final def process = [ 'svn', 'info', '--show-item', 'repos-root-url', '--no-newline' ].execute(null, projectDir)
		if (process.waitFor()) {
			logger.lifecycle "   -> Can't get subversion revision"
		}
		else {
			final boolean isolateNumericBuildParts = false
			final String urlSvnRepos = process.text.trim()
			logger.lifecycle "   Reading subversion revision (repos-root-url: »${urlSvnRepos}«)"
			final def process2 = [ 'svn', 'info', '--show-item', 'revision', '--no-newline', urlSvnRepos ].execute()
			if (process2.waitFor()) {
				logger.lifecycle "   -> Can't get head revision from subversion server" +
				        " -> falling back to reading local working copy revision"
				final def process3 = [ 'svnversion', '-n' ].execute(null, projectDir)
				if (process3.waitFor()) {
					logger.lifecycle " -> Can't get subversion revision"
					svnRev = ''
				}
				else {
					svnRev = process3.text.trim()
					if (svnRev) {
						// create valid semantic version build-nr:
						svnRev = 'r' + svnRev.replaceAll('[^0-9a-zA-Z]+' , '.')
						svnRev = svnRev.endsWith('.') ? svnRev.substring(0, n-1) : svnRev
						if (isolateNumericBuildParts) {
							final int n = svnRev.length()
							final def s = new StringBuilder();
							final def p = ~/([a-zA-Z][0-9])|([0-9][a-zA-Z])/
							for (int i = 1; i < n; i++) {
								s.append(svnRev.substring(i-1, i))
								if (svnRev.substring(i-1, i+1) ==~ p) s.append('.')
							}
							svnRev = s.append(svnRev.substring(n-1, n)).toString()
						}
					}
				}
			} else {
				svnRev = process2.text.trim()
				svnRev = (isolateNumericBuildParts ? 'r.' : 'r') + ((svnRev as Integer) + 1)
			}
			logger.lifecycle "   -> subversion revision is »${svnRev}«"
		}
	}
	return svnRev
}

final String versionBase = '4.0.0'

final String build_nr = readSvnRevision()
final String semVer = build_nr ? "${versionBase}+${build_nr}" : versionBase

final def regexSemVer = ~/^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/
if (!(semVer =~ regexSemVer)) throw new StopExecutionException("Invalid semantic version »${semVer}«")

final def fileVersionShield = file("doc/shields/version.svg")
		
allprojects {
	group = 'de.bernd_michaely'
	version = semVer
	
	ext.versionJUnit = '5.11.3'
	
	repositories {
		mavenCentral()
		//mavenLocal()
	}

	if ((project == rootProject) || name.endsWith('-fx')) {
		apply plugin: 'org.openjfx.javafxplugin'
		javafx {
			version = "21.0.5"
		}
		logger.lifecycle "-> Applying JavaFX ${javafx.version} plugin to project »$path«"
	}
}

logger.lifecycle "Running Gradle $project.gradle.gradleVersion"
logger.lifecycle "Java source level           : ${java.sourceCompatibility}"
logger.lifecycle "Compile      -> Debug-Level : ${compileJava.options.debug}"
logger.lifecycle "Test-Compile -> Debug-Level : ${compileTestJava.options.debug}"
logger.lifecycle "Modularity enabled          : ${java.modularity.inferModulePath.get()}"
logger.lifecycle "==> Root project »$name ($version)«"
logger.lifecycle " -> Base dir is »${file('.')}«"
logger.lifecycle " -> Using »JUnit         ${versionJUnit}«"
logger.lifecycle " -> Included child projects : »${childProjects.keySet()}«"
logger.lifecycle " -> Maven coordinates »${group}:${name}:${version}«"

subprojects {
	tasks.withType(JavaCompile).configureEach {
		javaCompiler = javaToolchains.compilerFor {
			languageVersion = javaLangVersion
			vendor = jvmVendor
		}
	}
	tasks.withType(Test).configureEach {
		javaLauncher = javaToolchains.launcherFor {
			languageVersion = javaLangVersion
			vendor = jvmVendor
		}
	}
	logger.lifecycle "==> Configuring sub-project »$name ($version)«"
	tasks.withType(JavaCompile) {
		logger.lifecycle "=> Configuring task »$name«"
		options.compilerArgs += '-Xlint:unchecked'
		options.compilerArgs += '-Xlint:deprecation'
		options.compilerArgs += '-Xdiags:verbose'
		logger.lifecycle "   -> compiler args : ${options.compilerArgs}"
	}
}

dependencies {
	implementation project (':module-gui-fx')
}

task writeSemVer {
	description "Write application semantic version to resource file »${fileSemVer}«"
	group processResources.group
	doFirst {
		if (isReadingSvnRevision) {
			final def process = [ 'svn', 'status' ].execute(null, projectDir)
			// only write new version if svn status is NOT clean:
			if (!process.waitFor() && process.text) fileSemVer.write(semVer)
		}
	}
}
processResources.dependsOn writeSemVer

def String toShieldParam(String text) {
	text.replaceAll("-", "--").replaceAll("_", "__").replaceAll("\\s", "_")
}

task getVersionShield {
	description "Generate a version shield by accessing shields.io and write it to file »${fileVersionShield}«"
	group javadoc.group
	doLast {
		final String label = toShieldParam(project.name)
		final String message = toShieldParam(project.version - ~'\\+.*$' - ~'-snapshot$')
		final URL url = new URI("https://img.shields.io/badge/${label}-${message}-blue").toURL()
		logger.lifecycle "→ getting data from URL »${url}«"
		fileVersionShield.write(url.getText())
	}
}

application {
	mainModule = 'de.bernd_michaely.chiffres.fx'
	mainClass  = 'de.bernd_michaely.chiffres.fx.JChiffresFXApplication'
}

jar {
	javafx {
		modules = [ 'javafx.base', 'javafx.graphics', 'javafx.controls', 'javafx.swing' ]
	}

	manifest {
		attributes ( 'Main-Class' : "${application.mainModule.get()}/${application.mainClass.get()}" )
	}
}
		
run {
	logger.lifecycle " -> run task modularity : ${modularity.inferModulePath.get()}"
	systemProperty 'java.util.logging.config.file', file('logging.properties')
}

